<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>cfz blog</title>
    <link>http://johnchancfz.github.io/blog</link>
    <description>My personal blog</description>
    
      <item>
        <title>局域网技术</title>
        <link>http://johnchancfz.github.io/blog/2016/03/21/Local-Area-Network.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2016/03/21/Local-Area-Network.html</guid>
        <pubDate>Mon, 21 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1、局域网（LAN）是在一个较小的范围（几公里到几十公里）内将各种通信设备和计算机互连起来已实现资源共享和消息交换的计算机网络。局域网具有覆盖范围小、传输速率高、通信延迟小、误码率低的特点。 
2、从传输技术上，计算机网络分为广播网和点到点网两大类。点到点网中，两个网络节点间存在直接的通信信道才能进行数据通信。在广播网中，所有网络节点共享同一个通信信道，每个节点发出的消息都可以被所有其他的节点接收。在广播网中存在信道争用的问题，如果有两个或多个网络节点同时发送数据，则数据信号会在信道中发生碰撞，导致数据发送失败，这个过程被称为冲突。在所有的广播网中都必须要面对和解决的一个关键问题就是：当信道的使用存在竞争时，如何分配信道的使用权。 
3、广播信道有时被称为多路访问信道或随机访问信道，通信信道又称介质，网络节点使用信道进行通信称为介质访问，协调各网络节点的行为、决定广播信道使用权的协议就称为介质访问控制协议。 
4、介质访问控制子层MAC，用来实现广播网中的信道分配，解决信道争用问题。点到点网中没有MAC子层的概念。 
几乎所有的局域网都以广播信道作为通信的基础。 
5、广播信道的分配策略主要包括静态分配策略和动态分配策略两大类。
6、静态分配策略包括频分多路复用和同步时分多路复用。这种分配策略是预先将频带或时隙固定分配给各个网络节点。各节点都有自己专用的频带或时隙，彼此之间不会产生干扰。静态分配策略适用于网络节点数目少而固定，且每个节点都有大量数据要发送的场合，信道利用率较高。 
7、动态分配策略包括随即访问和控制访问，本质上属于异步时分多路复用。随机访问又称争用。控制访问有两种方法：轮转和预约。轮转是使每个网络节点轮流获得信道的使用权，没有数据要发送的节点将使用权传给下一节点。预约是各个网络节点首先声明自己有数据要发送，然后根据声明的顺序依次获得信道的使用权来发送数据&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>2016年阅读书单</title>
        <link>http://johnchancfz.github.io/blog/2016/01/28/Book-List-2016.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2016/01/28/Book-List-2016.html</guid>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0800</pubDate>
        <description></description>
      </item>
    
      <item>
        <title>吉他上弦枕的DIY调节</title>
        <link>http://johnchancfz.github.io/blog/2015/10/26/Do-with-your-guitar.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/10/26/Do-with-your-guitar.html</guid>
        <pubDate>Mon, 26 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;code&gt;博客作者已获得原文作者Akira Satoyoshi授权翻译发表&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;惯例开场故事&lt;/h3&gt;

&lt;p&gt;今年4月底，我买了一把Maton ebg808TE。对新琴爱不释手，却苦于弦距太高，手感不适。经过测量，12品弦距达到了3mm。其实12品弦距在2.5mm~3.5mm之间属于正常范围，但我之前的Martin 000x1ae在1品和12品的弦距都非常低，我习惯了这样的手感。&lt;/p&gt;

&lt;p&gt;5月初，在Youtube上我观看了一些Maton ebg808TE的视频，其中一个就是Akira弹奏的。我被他的演奏打动了，也就想试着请教一下他关于这把琴应该怎样调整手感。当时仅仅是在Youtube上简单的留言，Akira很快地回复了我，并给我留了邮箱以便我咨询更多的问题。&lt;/p&gt;

&lt;p&gt;我试着发了封信过去，请教他对于Maton ebg808TE这把琴，在琴颈调直的情况下，应该怎样做才能将手感调得更好。&lt;/p&gt;

&lt;p&gt;Akira回复的经验大概如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打磨下弦枕可以调节12品弦距，若想12品弦距减少n毫米，则需要将下弦枕磨短2n毫米&lt;/li&gt;
&lt;li&gt;但1品弦距无法通过打磨下弦枕调节&lt;/li&gt;
&lt;li&gt;需要挫上弦枕调节1品弦距&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非常感谢一个陌生人愿意花时间去教另一个陌生人，并写得如此详细。还记得当时阅读邮件的感动。这里我把Akira教我的关于处理上弦枕的邮件发表出来，也许可以帮助到更多的吉他爱好者。&lt;/p&gt;

&lt;h3&gt;相关术语&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;nut 上弦枕&lt;/li&gt;
&lt;li&gt;saddle 下弦枕&lt;/li&gt;
&lt;li&gt;action 弦距&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Akira给我的回信译文&lt;/h3&gt;

&lt;p&gt;嗨，那你先看一下这个视频吧。这个视频可以让你更好地明白怎样才能从吉他琴颈上取下上弦枕。把上弦枕拿下来并不是一件非常困难的事，但在你清理上弦枕拿下后的那个琴颈上的槽沟时得格外小心。槽沟里有时会有残留的胶水，你需要把它们弄干净，之后才能把新的上弦枕放进去。否则新上弦枕的底部无法与琴颈槽沟完美接触，而这会影响到琴的声音。&lt;/p&gt;

&lt;p&gt;关于制作一个新的上弦枕，我推荐以下的网站和视频。它们真的能帮上大忙。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.strangeguitarworks.com/guitar-nut-from-scratch/&quot;&gt;http://www.strangeguitarworks.com/guitar-nut-from-scratch/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://diystrat.blogspot.com.au/2010/10/making-bone-nut-from-scratch.html?m=1&quot;&gt;http://diystrat.blogspot.com.au/2010/10/making-bone-nut-from-scratch.html?m=1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://m.youtube.com/watch?v=kn1z2R-w3i4&quot;&gt;https://m.youtube.com/watch?v=kn1z2R-w3i4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下图是许多人讨论得出的理想的上弦枕上六个琴弦槽的深度，我也觉得这样的琴弦槽深度是最好的。对于第六、五、四弦，琴弦槽的深度应该保证让琴弦的上半部分露在槽的外面，这能让琴弦有更好的震动。对于第三、二、一弦，槽的深度应该让琴弦正好完全陷入槽内。在自己的琴上，我甚至让第三弦也露出弦槽一丁点儿，我觉得这样声音更好。所以当你调整上弦枕的弦槽深度时，你也许需要锉得比较深才能获得完美的弦距。然而如此一来，琴弦就会太过陷入上弦枕，所以你还需要把上弦枕上部多余的部分挫掉，好让琴弦安放得像图中那样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut.png&quot; alt=&quot;01&quot;&gt;&lt;/p&gt;

&lt;p&gt;下图显示的是琴弦与上弦枕的整体接触程度。当你在挫琴弦槽的时候，你要确保槽沟是有角度的，这个角度朝向琴弦钮，不能太高，也不能低于琴弦穿过的琴弦钮上的洞。&lt;/p&gt;

&lt;p&gt;（未完待续...如果需要可先阅读原文）&lt;/p&gt;

&lt;h3&gt;回信原文&lt;/h3&gt;

&lt;p&gt;Hi, ok then first you can watch this vedio. This is a very good video to understand how to remove the nut. Removing a nut isn&amp;#39;t very difficult. But be very careful when you clean the slot on the neck. There&amp;#39;s sometimes old glue left in the slot and you have to get rid of it before putting a new nut in. Otherwise the bottom of the new nut won&amp;#39;t touch the slot perfectly and it affects the sound.&lt;/p&gt;

&lt;p&gt;For making a new nut I liked those websites and videos. They are really helpful.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.strangeguitarworks.com/guitar-nut-from-scratch/&quot;&gt;http://www.strangeguitarworks.com/guitar-nut-from-scratch/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://diystrat.blogspot.com.au/2010/10/making-bone-nut-from-scratch.html?m=1&quot;&gt;http://diystrat.blogspot.com.au/2010/10/making-bone-nut-from-scratch.html?m=1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://m.youtube.com/watch?v=kn1z2R-w3i4&quot;&gt;https://m.youtube.com/watch?v=kn1z2R-w3i4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The photo below is the ideal nut slot depth that many people talk about and I think it&amp;#39;s true. I like it too.  For the 6th ~ 4th strings, the depth should be that the top half of the strings sticks out of the nut slots. This allows the strings vibrates more.  For the 3rd ~ 1st strings, the depth should be that the strings are just completely in the slots. I even made the 3rd strings stick out a little and it sounds better. So when you are adjusting the nut slot depth, you might have to file it quite deep to get the perfect action for you. In that case the strings are too deep in the nut, then you&amp;#39;ll have to file down the top of the nut so that the strings sit just like the photos below. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;The photos below is about how much of the strings are touching(sitting) on the nut. When you file a nut slots you have to make sure that you file it at an angle TOWARDS the string post hole, not too high or low than the hole. &lt;/p&gt;

&lt;p&gt;After filing the slots, you can file down the yellow part by filing at a sharper angle(lower than the string post hole) so strings DON&amp;#39;T touch the filed part.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut_angle.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;p&gt;This is a photo looking at a nut from above after you&amp;#39;ve filed the yellow part.  The black part is where strings are touching. Like 50% of the strings are sitting on the nut. By doing this the tension on the strings become lighter, making it easy to play. And the sound becomes brighter compared to when you don&amp;#39;t do this trick. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut_concave.png&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;p&gt;This photo is about intonation.  &lt;/p&gt;

&lt;p&gt;When you file nut slots, make sure the highest contact point is at the blue circled spot( exactly where the nut and fretboard touch each other). &lt;/p&gt;

&lt;p&gt;If you file the slot like the yellow line, the highest point is on the yellow circled spot. It means it&amp;#39;s like the scale of your guitar neck is longer which makes your guitar go out of tune all the time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut_good.png&quot; alt=&quot;4&quot;&gt;&lt;/p&gt;

&lt;p&gt;Nut has to fit without any gap on all the sides and bottom like this photo. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut_real.png&quot; alt=&quot;5&quot;&gt;&lt;/p&gt;

&lt;p&gt;You can check it with a light like this. I just used my iPhone torch and it works fine. If there&amp;#39;s gap you can see the light coming through and it&amp;#39;s not a good news! &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/guitar_nut_light.png&quot; alt=&quot;6&quot;&gt;&lt;/p&gt;

&lt;p&gt;For nut action, this website below is so great. A perfect explanation. I think this part is the main reason you want to replace the nut right?&lt;/p&gt;

&lt;p&gt;Oh and Is your 808TE a newer model? If yours has a kangaroo inlay and reddish colour back and sides, the nut and saddles are bone. My older model had black nut and saddle made of some mixture of glass and plastic. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.frets.com/FretsPages/Musician/GenSetup/NutAction/nutaction.html&quot;&gt;http://www.frets.com/FretsPages/Musician/GenSetup/NutAction/nutaction.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I learnt everything on the internet. So you can do research by your self too. Just search by  &amp;quot;how to shape a guitar nut&amp;quot; &amp;quot;how to file nut slots&amp;quot;. And it will show you lots of links. Lots of videos available on youtube too.  One of the important thing I can say is that to do it slowly, don&amp;#39;t rush and be patient because once you file a nut too much, you&amp;#39;ll have to start a new one again!&lt;/p&gt;

&lt;p&gt;Let me know if you need anything else. &lt;/p&gt;

&lt;p&gt;First work on nut then you can change the saddle. &lt;/p&gt;

&lt;p&gt;If you need my help for the saddle, just write me again and I&amp;#39;ll give you some advise.  Just be gentle on your guitar because you don&amp;#39;t wanna wreck your guitar! No one wants to:)
Good luck! &lt;/p&gt;

&lt;p&gt;Akira&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>找工作总结</title>
        <link>http://johnchancfz.github.io/blog/2015/10/21/My-Job.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/10/21/My-Job.html</guid>
        <pubDate>Wed, 21 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
&lt;p&gt;误打误撞拿到心仪的Offer后，反而突然又能静下来一个人在夜里的实验室默默推公式做仿真了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;明年6月底毕业，目前已经签了心仪的公司，算是找工作阶段的完结。在这里总结一下找工作的历程。&lt;/p&gt;

&lt;h3&gt;找工作记录表&lt;/h3&gt;

&lt;p&gt;在今年8月底准备找工作之前，我仿照项目管理给自己做了个表，之后的一个月就是按照实际的进展将表中空格填满而已。截止到现在，我面试过的公司按时间先后顺序有三家：腾讯、远景能源、秒针系统。拿到远景能源和秒针系统的offer。最后选择了&lt;a href=&quot;http://www.miaozhen.com/&quot;&gt;秒针系统&lt;/a&gt;，这其实是一个之前不在考虑范围内的选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp1z.com1.z0.glb.clouddn.com/jobs.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;表中最后一列颜色含义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;红色：拿到Offer&lt;/li&gt;
&lt;li&gt;黑色：被拒&lt;/li&gt;
&lt;li&gt;绿色：放弃&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;我的背景&lt;/h3&gt;

&lt;p&gt;我在研究生阶段的研究方向是分布式凸优化，是很理论的东西。常规的后续发展有两条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在学术圈发展。这通常需要继续读博士，联系博后，然后进入高校或研究所工作。&lt;/li&gt;
&lt;li&gt;进入工业界发展。最优化计算方法在这个时代其实有非常广泛的应用，但工业界对于理论研究的人才选拔标准很高，通常是已经学术有成的科学家空降到企业去带领团队。对于非计算机系硕士毕业生而言，想进入工业界继续做技术相关工作，除了必备的数学基础，还需要有较强的编程能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在研二上期，结合自身的性格、优势、追求，我选择了一条非常规发展道路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进入技术性导向强的公司担任产品岗工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样选择有几个好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;充分发挥个人综合能力&lt;/li&gt;
&lt;li&gt;不荒废研究生阶段积累起来的科研能力（我的梦想真是当一个科学家，然而未遂）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;三家面试&lt;/h3&gt;

&lt;h4&gt;腾讯&lt;/h4&gt;

&lt;p&gt;3月份的时候申请腾讯实习，做过笔试题了，所以校招免笔试通过。之后是去杭州参加常规的腾讯校招面试，不过很遗憾没有拿到Offer。&lt;/p&gt;

&lt;h4&gt;远景能源&lt;/h4&gt;

&lt;p&gt;这是一家做风机和光伏电池管理软件的公司，产品面试官和HR，以及场外的吴经理人都非常好。但终面时Boss极其强悍。这家公司吸引我的是新能源未来的发展前景，以及其超前提出的能源互联网的概念。我在这方面有一定了解，但就我个人的认知来讲，在充电和储电技术还没有质变发展的今天，能源互联网更多还只是概念性的东西。有兴趣的同学其实不妨赌一把，现在进入这个行业，说不定真有机会成为先驱哦。我个人还蛮向往有机会能去草原上爬个风机的。最后拿到Offer，但因为已经心仪秒针系统了，婉拒掉。&lt;/p&gt;

&lt;h4&gt;秒针系统&lt;/h4&gt;

&lt;p&gt;秒针系统产品工程师的笔试题目让我很有好感，因为除了最后两道产品设计题之外，考的都是数学题。在第二天的面试中，除了产品面试官外，我们科大的师兄（哈哈哈看上去应该是技术牛宅）也挤过来很happy地问我数学题，整个面试过程气氛都很好，包括最后和HR Jason聊天。Jason当场给了我口头Offer，两天后电话告知Offer和薪资。&lt;/p&gt;

&lt;h3&gt;确定选择&lt;/h3&gt;

&lt;p&gt;我心中对于工作的选择标准大概如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;技术性导向强，能用上最优化算法更好&lt;/li&gt;
&lt;li&gt;所研发的产品发展前景好&lt;/li&gt;
&lt;li&gt;专业领域领头&lt;/li&gt;
&lt;li&gt;公司所在城市不比重庆差&lt;/li&gt;
&lt;li&gt;薪资符合预期&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说实话，在接到秒针Offer的当晚，我能够立马确定的仅4、5条满足。之前关于未来从事的产品设想完全没有涉及计算广告或者实时竞价（这是自己了解得太少）。拿到Offer之后，花了几天时间去调研，包括与实验室已毕业师兄聊天、与在秒针工作的科大师兄了解、自己查阅资料、自己阅读《计算广告》一书，等等。其中值得一提的是，调研过程中意外地发现&lt;a href=&quot;http://diaorui.net/&quot;&gt;刁瑞师兄&lt;/a&gt;在2013年参加过秒针系统主办的RTB算法大赛并夺魁，而刁瑞师兄一直是一个传说中的男神，我研二上期在中科院数学与系统科学研究院访问时就知道他的存在了。话转回来，通过这个契机我认真地学习了一些RTB的知识，感到非常开心，因为问题模型全部都是优化问题，满足标准1。也因为有了进一步的了解，我有自信未来自己研发的产品能达到标准2。至于标准3，目前做实时竞价的公司不止秒针，大家都说自己是行业领头，我没有内部数据无从判断，只是想到有那么多科大师兄在那里工作，公司的技术一定不会差，因此标准3达到。&lt;/p&gt;

&lt;p&gt;另外，关于对小公司和大公司的选择，在很早之前，我就思考过这个问题。从统计意义上讲，选择去大公司是更保险的做法。但如果按照统计数据去走我们的一生，对我而言缺少了一些意外美感。秒针这样小而美的公司，其实更吸引我。于是，我愉快地联系了Jason确认接受Offer。因为心里已经认定了秒针系统，上表中其他公司的笔试或面试，我都放弃了。&lt;/p&gt;

&lt;h3&gt;感谢&lt;/h3&gt;

&lt;p&gt;这一路还是要感谢很多人，你们或多或少地都在我找工作的过程中给予我帮助。名字都在我心中，不列了~&lt;/p&gt;

&lt;h3&gt;下一步&lt;/h3&gt;

&lt;p&gt;抓紧最后的学生时光好好学习，好好总结，好好毕业。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>从二次型最优化问题中理解矩阵特征值的意义</title>
        <link>http://johnchancfz.github.io/blog/2015/09/12/Intuition-of-Eigen-Value.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/09/12/Intuition-of-Eigen-Value.html</guid>
        <pubDate>Sat, 12 Sep 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;惯例开场故事&lt;/h3&gt;

&lt;p&gt;在某次从实验室去往食堂的路上，曾发生这样一段对话：&lt;/p&gt;

&lt;p&gt;『大师兄，为什么你对算法的理解总是那么透彻呢？为什么我很难看出它背后的思想？』&lt;/p&gt;

&lt;p&gt;『因为你去理解一个算法的时候，不能只是看懂它的形，还要去思考它的神啊~』&lt;/p&gt;

&lt;p&gt;这就是我天分不够当不了科学家的佐证吧T。T&lt;/p&gt;

&lt;h3&gt;从二次型最优化来理解&lt;/h3&gt;

&lt;p&gt;最小化二次型目标函数&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=x^TAx&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=x^TAx&quot; title=&quot;f(x)=x^TAx&quot; /&gt;&lt;/a&gt;，其中A为已知的实对称二阶矩阵，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=A=[1,0.5;0.5,1]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?A=[1,0.5;0.5,1]&quot; title=&quot;A=[1,0.5;0.5,1]&quot; /&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x=[x_1,x_2]^{\textrm{T}}&amp;space;\in&amp;space;\textcal{R}^2&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x=[x_1,x_2]^{\textrm{T}}&amp;space;\in&amp;space;\textcal{R}^2&quot; title=&quot;x=[x_1,x_2]^{\textrm{T}} \in \textcal{R}^2&quot; /&gt;&lt;/a&gt;.这个问题的求解很简单，这里以此为例来说明该问题与矩阵特征值的关系。&lt;/p&gt;

&lt;p&gt;首先，可以得到目标函数的网格图与等高线图如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/mesh_of_f.png&quot; alt=&quot;1&quot;&gt;
&lt;img src=&quot;/public/img/posts/contour_of_f.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;p&gt;对矩阵A进行特征分解可以得到其特征向量为[-0.7071, 0.7071], [0.7071, 0.7071]，对应的特征值分别是0.5, 1.5.&lt;/p&gt;

&lt;p&gt;观察函数的等高线图可以知道，等高线最密集的地方，函数值变化最快，而这个函数值变化最快的方向归一化后就是[0.7071, 0.7071]，这恰好是矩阵的一个特征向量。同样地，可以观察，等高线最稀疏的地方，函数值变化最慢，变化方向则是矩阵的另一个特征向量。可以看出，&lt;code&gt;矩阵特征值的大小与函数值的变化快慢有关&lt;/code&gt;，较大特征值所对应的特征向量方向上函数值的变化较快，较小特征值所对应的特征向量方向上函数值的变化较慢。&lt;/p&gt;

&lt;p&gt;进一步，对于实对称矩阵，我们总是可以对其进行相似变化，得到一个以该矩阵特征值为对角线元素的对角阵。&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=P^{-1}AP=B&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?P^{-1}AP=B&quot; title=&quot;P^{-1}AP=B&quot; /&gt;&lt;/a&gt;，其中，P为正交矩阵，有性质P的逆等于P的转置。把目标函数改写为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; title=&quot;f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; /&gt;&lt;/a&gt;，其中&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=B=[0.5,&amp;space;0;&amp;space;0,&amp;space;1.5]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?B=[0.5,&amp;space;0;&amp;space;0,&amp;space;1.5]&quot; title=&quot;B=[0.5, 0; 0, 1.5]&quot; /&gt;&lt;/a&gt;. 相似变换的作用可以理解为将等高线图进行旋转，于是得到下面经过旋转后的等高线图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/contour_of_f_B.png&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这张图上说明矩阵特征值的意义。当函数值取1时所对应的椭圆等高线的长轴长度为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\frac{1}{\sqrt{0.5}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\frac{1}{\sqrt{0.5}}&quot; title=&quot;\frac{1}{\sqrt{0.5}}&quot; /&gt;&lt;/a&gt;， 即由矩阵特征值0.5决定。同理，该椭圆短轴长度为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\frac{1}{\sqrt{1.5}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\frac{1}{\sqrt{1.5}}&quot; title=&quot;\frac{1}{\sqrt{1.5}}&quot; /&gt;&lt;/a&gt;，由矩阵特征值1.5决定。&lt;/p&gt;

&lt;p&gt;二阶矩阵的理解较为直观。高阶矩阵的道理是一样的。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.zhihu.com/question/21874816/answer/19592526&quot;&gt;如何理解矩阵特征值&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>租房奇遇记</title>
        <link>http://johnchancfz.github.io/blog/2015/07/05/Never-Trust-the-Word-from-Qipa.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/07/05/Never-Trust-the-Word-from-Qipa.html</guid>
        <pubDate>Sun, 05 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/days/ca.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;故事&lt;/h3&gt;

&lt;p&gt;“人生真的是一场很长的修炼，我还处于小白阶段。”记第一次租房被耍。&lt;/p&gt;

&lt;p&gt;2015.09.29补充：
我确实是一个很幸运的人，在被奇怪的房东耍过之后，居然又开启一段神奇的际遇：在四位善良的『陌生同学』的帮助下，我在北京没有交一分钱房租而度过了大半个暑假。真的，谢谢大家。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）</title>
        <link>http://johnchancfz.github.io/blog/2015/03/23/Newton-QuasiNewton-Method.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/03/23/Newton-QuasiNewton-Method.html</guid>
        <pubDate>Mon, 23 Mar 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最近做LBFGS的并行，顺便把牛顿法、拟牛顿法顺理一下。&lt;/p&gt;

&lt;p&gt;拟牛顿法是求解非线性优化问题最有效的方法之一。考虑无约束的极小化问题&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\min\limits_x&amp;space;f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\min\limits_x&amp;space;f(x)&quot; title=&quot;\min\limits_x f(x)&quot; /&gt;&lt;/a&gt;，假设&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)&quot; title=&quot;f(x)&quot; /&gt;&lt;/a&gt;为凸函数，且二阶连续可导。&lt;/p&gt;

&lt;h3&gt;原始牛顿法&lt;/h3&gt;

&lt;p&gt;基本思想：在现有极小点估计值的附近对f(x)进行二阶泰勒展开，进而找到下一个极小点的估计值&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{k&amp;plus;1}=x_{k}-(H_k)^{-1}g_{k},&amp;space;k=0,1,\cdots&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{k&amp;plus;1}=x_{k}-(H_k)^{-1}g_{k},&amp;space;k=0,1,\cdots&quot; title=&quot;x_{k+1}=x_{k}-(H_k)^{-1}g_{k}, k=0,1,\cdots&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;牛顿法具有二次收敛性，但当目标函数非二次型时，牛顿法不能保证函数稳定地下降（缺点）。&lt;/p&gt;

&lt;h3&gt;阻尼牛顿法&lt;/h3&gt;

&lt;p&gt;每次迭代前需要沿迭代方向&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=d_k=-(H_k)^{-1}g_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?d_k=-(H_k)^{-1}g_k&quot; title=&quot;d_k=-(H_k)^{-1}g_k&quot; /&gt;&lt;/a&gt;做线搜索，寻求最优的步长因子&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\lambda_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\lambda_k&quot; title=&quot;\lambda_k&quot; /&gt;&lt;/a&gt;，即&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\lambda_k&amp;space;=&amp;space;\arg\min\limits_{\lambda}&amp;space;f(x_k&amp;plus;\lambda&amp;space;d_k)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\lambda_k&amp;space;=&amp;space;\arg\min\limits_{\lambda}&amp;space;f(x_k&amp;plus;\lambda&amp;space;d_k)&quot; title=&quot;\lambda_k = \arg\min\limits_{\lambda} f(x_k+\lambda d_k)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;拟牛顿法&lt;/h3&gt;

&lt;p&gt;基本思想：不使用二阶偏导数而构造出可以近似Hession或Hession的逆的正定对称阵，在“拟牛顿”的条件下优化目标函数。&lt;/p&gt;

&lt;p&gt;先推导拟牛顿条件：在&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{k&amp;plus;1}&quot; title=&quot;x_{k+1}&quot; /&gt;&lt;/a&gt;附近对&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)&quot; title=&quot;f(x)&quot; /&gt;&lt;/a&gt;做泰勒展开，取二阶近似项&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=f(x_{k&amp;plus;1})&amp;plus;\nabla&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&amp;plus;\frac{1}{2}(x-x_{k&amp;plus;1})^T\nabla^2&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=f(x_{k&amp;plus;1})&amp;plus;\nabla&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&amp;plus;\frac{1}{2}(x-x_{k&amp;plus;1})^T\nabla^2&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&quot; title=&quot;f(x)=f(x_{k+1})+\nabla f(x_{k+1})(x-x_{k+1})+\frac{1}{2}(x-x_{k+1})^T\nabla^2 f(x_{k+1})(x-x_{k+1})&quot; /&gt;&lt;/a&gt;
推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\nabla&amp;space;f(x)\approx&amp;space;\nabla&amp;space;f(x_{k&amp;plus;1})&amp;plus;H_{k&amp;plus;1}(x-x_{k&amp;plus;1})&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\nabla&amp;space;f(x)\approx&amp;space;\nabla&amp;space;f(x_{k&amp;plus;1})&amp;plus;H_{k&amp;plus;1}(x-x_{k&amp;plus;1})&quot; title=&quot;\nabla f(x)\approx \nabla f(x_{k+1})+H_{k+1}(x-x_{k+1})&quot; /&gt;&lt;/a&gt;
取&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x=x_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x=x_k&quot; title=&quot;x=x_k&quot; /&gt;&lt;/a&gt;，推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=g_{k&amp;plus;1}-g_{k}\approx&amp;space;H_{k&amp;plus;1}(x_{k&amp;plus;1}-x_k)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?g_{k&amp;plus;1}-g_{k}\approx&amp;space;H_{k&amp;plus;1}(x_{k&amp;plus;1}-x_k)&quot; title=&quot;g_{k+1}-g_{k}\approx H_{k+1}(x_{k+1}-x_k)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;引入记号 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=s_k=x_{k&amp;plus;1}-x_{k},&amp;space;y_k=g_{k&amp;plus;1}-g_{k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?s_k=x_{k&amp;plus;1}-x_{k},&amp;space;y_k=g_{k&amp;plus;1}-g_{k}&quot; title=&quot;s_k=x_{k+1}-x_{k}, y_k=g_{k+1}-g_{k}&quot; /&gt;&lt;/a&gt;， 推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=y_k=H_{k&amp;plus;1}s_k&amp;space;,&amp;space;s_k=H^{-1}_{k&amp;plus;1}y_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?y_k=H_{k&amp;plus;1}s_k&amp;space;,&amp;space;s_k=H^{-1}_{k&amp;plus;1}y_k&quot; title=&quot;y_k=H_{k+1}s_k , s_k=H^{-1}_{k+1}y_k&quot; /&gt;&lt;/a&gt;(&lt;code&gt;拟牛顿条件&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;它迭代过程中的hession矩阵做约束，因此，对hession对近似的&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=B_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?B_{k&amp;plus;1}&quot; title=&quot;B_{k+1}&quot; /&gt;&lt;/a&gt;，以及对hession的逆做近似的&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_{k&amp;plus;1}&quot; title=&quot;D_{k+1}&quot; /&gt;&lt;/a&gt;，可以将&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=y_{k}=B_{k&amp;plus;1}s_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?y_{k}=B_{k&amp;plus;1}s_k&quot; title=&quot;y_{k}=B_{k+1}s_k&quot; /&gt;&lt;/a&gt; 或 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=s_{k}=D_{k&amp;plus;1}y_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?s_{k}=D_{k&amp;plus;1}y_k&quot; title=&quot;s_{k}=D_{k+1}y_k&quot; /&gt;&lt;/a&gt; 作为指导。&lt;/p&gt;

&lt;h4&gt;DFP算法（Davidon–Fletcher–Powell formula）&lt;/h4&gt;

&lt;p&gt;核心：通过迭代的方法，对hession的逆做近似。迭代格式为&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_{k&amp;plus;1}=D_k&amp;plus;\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_{k&amp;plus;1}=D_k&amp;plus;\Delta&amp;space;D_k&quot; title=&quot;D_{k+1}=D_k+\Delta D_k&quot; /&gt;&lt;/a&gt;（通常&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_0=I&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_0=I&quot; title=&quot;D_0=I&quot; /&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;猜想&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k&quot; title=&quot;\Delta D_k&quot; /&gt;&lt;/a&gt;待定为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k=\alpha&amp;space;\mathbf{u}&amp;space;\mathbf{u}^{\mathrm{T}}&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k=\alpha&amp;space;\mathbf{u}&amp;space;\mathbf{u}^{\mathrm{T}}&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; title=&quot;\Delta D_k=\alpha \mathbf{u} \mathbf{u}^{\mathrm{T}}+\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; /&gt;&lt;/a&gt;（具有对称性）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;s_k=D_ky_k&amp;plus;\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k&amp;plus;(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}&amp;plus;(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;s_k=D_ky_k&amp;plus;\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k&amp;plus;(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}&amp;plus;(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; title=&quot;\Rightarrow s_k=D_ky_k+\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k+\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k+(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}+(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;括号中是数值，将其分别简单赋值为1，-1，即&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; title=&quot;\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中向量u,v仍有待确定，由上面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; title=&quot;\Rightarrow \mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; /&gt;&lt;/a&gt;（要此式成立，不妨直接取&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; title=&quot;\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; /&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; title=&quot;\Rightarrow \alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至此，校正矩阵&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k&quot; title=&quot;\Delta D_k&quot; /&gt;&lt;/a&gt;就已经构造出来了&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\Delta&amp;space;D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\Delta&amp;space;D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; title=&quot;\Rightarrow \Delta D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;BFGS算法（Broyden–Fletcher–Goldfarb–Shanno algorithm）&lt;/h4&gt;

&lt;p&gt;核心公式的推导过程与DFP完全类似，只是互换了其中s{k}和y{k}的位置。BFGS直接逼近Hession矩阵B_k。(公式敲起来太累了，请自行推导)&lt;/p&gt;

&lt;h4&gt;LBFGS算法(limited-memory BFGS)&lt;/h4&gt;

&lt;p&gt;不再存储完整的D&lt;em&gt;k，而是存储计算过程中的向量序列{s}，{y}。当需要矩阵D&lt;/em&gt;k时，利用向量序列的计算来代替。并且，向量序列也不是全部存储，而是固定存最新的m个。&lt;/p&gt;

&lt;p&gt;若要实现并行，需要同时在x与梯度（影响y的计算）那儿求一致平均。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://en.wikipedia.org/wiki/Davidon%E2%80%93Fletcher%E2%80%93Powell_formula&quot;&gt;DFP算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;http://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm&quot;&gt;BFGS算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【3】&lt;a href=&quot;http://en.wikipedia.org/wiki/Limited-memory_BFGS&quot;&gt;LBFGS算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【4】&lt;a href=&quot;http://papers.nips.cc/paper/5333-large-scale-l-bfgs-using-mapreduce.pdf&quot;&gt;Large-scale L-BFGS using MapReduce&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac以及Windows上搭建C++工作环境</title>
        <link>http://johnchancfz.github.io/blog/2015/02/13/Cplus-on-MAC.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/02/13/Cplus-on-MAC.html</guid>
        <pubDate>Fri, 13 Feb 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;实验室里我申请的垃圾老爷机被师弟玩坏了，弄了一天，最后发现根本就是硬件损伤，想把它砸掉！太坑了。&lt;/p&gt;

&lt;p&gt;clang是osx自带的c,c++,objective-c编译器；gnu是常用的c++的轻量级编译器，在windows上通常是下载MinGW；sublime就不多说了；本文的目的就是搭建一个轻量级的C++编辑-编译-调试-运行环境。&lt;/p&gt;

&lt;h2&gt;MAC上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开sublime，&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入install，选择&lt;code&gt;install package&lt;/code&gt;，回车&lt;/li&gt;
&lt;li&gt;输入sublimeClang，回车下载&lt;/li&gt;
&lt;li&gt;编写一个简单的c++程序，保存为name.cpp&lt;/li&gt;
&lt;li&gt;在terminal中，&lt;code&gt;clang++ name.cpp -o name&lt;/code&gt;或者&lt;code&gt;g++ name.cpp -o name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;双击name运行&lt;/li&gt;
&lt;li&gt;如果运行过程不需要输入数据，可以直接在sublime中&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt;运行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;AppStore中下载Xcode&lt;/li&gt;
&lt;li&gt;使用这个IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;WINDOWS上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装Installation Manager，运行，选择需要下载的组件，比如这里需要C++有关的组件&lt;/li&gt;
&lt;li&gt;将MinGW的安装路径添加到环境变量中&lt;/li&gt;
&lt;li&gt;cmd中输入&lt;code&gt;g++ -v&lt;/code&gt;来检测gnu是否安装成功&lt;/li&gt;
&lt;li&gt;打开sublime text 3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;browse packages&lt;/code&gt;-&amp;gt;&lt;code&gt;gcc&lt;/code&gt;(好像是这样，反正自己摸索就好了)&lt;/li&gt;
&lt;li&gt;OK，完成&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Visual Studio&lt;/li&gt;
&lt;li&gt;使用该IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;有用的资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/g++/index.html&quot;&gt;Writing and Running C++ Programs in the UNIX Environment using g++&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/xCode_Instructions/index.html&quot;&gt;Writing and Running C++ Programs in the Mac OS X 10.4 Environment using xCode&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>大数据机器学习初探---南大李武军</title>
        <link>http://johnchancfz.github.io/blog/2015/02/04/Group-Meeting.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/02/04/Group-Meeting.html</guid>
        <pubDate>Wed, 04 Feb 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;每周的组会大概会持续2小时。如果是主讲，就需要花更多的时间去准备报告内容。之前，组会开完我就不管了，缺乏总结思考。而这样子的话实质上意义就不大了，没有内化为自己的知识，也没有什么critical thinking。从现在开始，记录每一次组会的思考。&lt;/p&gt;

&lt;p&gt;常言道：亡羊补牢，为时未晚。T.T&lt;/p&gt;

&lt;h3&gt;Outline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Learning to Hash&lt;/li&gt;
&lt;li&gt;Distributed Learning&lt;/li&gt;
&lt;li&gt;Stochastic Learning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有一个形象的比喻是这样说的，大数据是金矿，云计算是采矿技术，大数据机器学习是冶金技术。&lt;/p&gt;

&lt;p&gt;大数据机器学习面临的挑战，一是存储，而是计算速度，三是网络。&lt;/p&gt;

&lt;p&gt;哈希学习，在内存、硬盘、cpu、通信上有优势；
分布式学习在内存、硬盘、cpu上有优势，但会增加通信成本；随机学习在内存、硬盘、cpu方面有优势。&lt;/p&gt;

&lt;h3&gt;Learning to Hash&lt;/h3&gt;

&lt;p&gt;主讲人：大师兄&lt;/p&gt;

&lt;p&gt;最近邻搜索在大数据背景下，会出现维数灾难，存储成本也高，查询速度也慢。解决方法之一是保相似性哈希，可以降低维数并减少存储成本。通常用海明距离（hamming distance）来表征哈希值之间的差异。哈希方案也具有较快的查询速度，通常具有常数或者次线性的搜索时间复杂度；即使是穷举搜索也可以被接受，因为海明距离计算起来是很快的。&lt;/p&gt;

&lt;p&gt;哈希函数学习的两个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Projection Stage（dimension reduction）&lt;/li&gt;
&lt;li&gt;Quantization Stage&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;贡献：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Isotropic Hash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思想：学习一个正交阵（幻灯片21页），其目的是让大于某一阈值的feature的重要程度是一样的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Supervised Hashing with Latent Factor Models&lt;/li&gt;
&lt;li&gt;Supervised Multimodal Hashing with SCM&lt;/li&gt;
&lt;li&gt;Multiple-Bit Quantization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Distributed Learning&lt;/h3&gt;

&lt;p&gt;主讲人：我&lt;/p&gt;

&lt;p&gt;主要内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文章：Coupled Group Lasso for Web-Scale CTR Prediction&lt;/li&gt;
&lt;li&gt;文章：Distributed Power-Law Graph Computing&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;文章1&lt;/h4&gt;

&lt;p&gt;为了解决在线广告的CTR（click through rate）预测，即当某广告展示给某用户时，它被该用户点击的概率，通常的方法是LR（logistic regression），即逻辑回归。但LR的一个短板是，因其是线性的，所以无法将用户与广告之间某些微妙的非线性关系纳入。注意LR中，正则项若为2范数平方，称为标准逻辑回归；正则项若为1范数，问题通常被叫做Lasso。所以需要一种新的方法。&lt;/p&gt;

&lt;p&gt;这里的贡献是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CGL的似然定义中，可以纳入用户与广告之间的某些非线性关系的考量。&lt;/li&gt;
&lt;li&gt;正则项改为参数的2-1范数，目的是是用户特征向量参数W、广告特征向量参数V中更多的行为0，行为0说明该行对应的feature没作用，即达到删除冗余feature的作用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分布式实现。这个算法具有较好的扩展性，一个master，若干slave，类似于并行计算，从而实现分布式。&lt;/p&gt;

&lt;h4&gt;文章2&lt;/h4&gt;

&lt;p&gt;GP（graph partitioning）图分割的方法有两种：边分割；点分割。点分割在分布式计算中的通信成本会比图分割小，原因在于在不同的machine上，点分割只需保留点的copy，而边分割需要同时保留点与边的copy。&lt;/p&gt;

&lt;p&gt;切割degree大的点，即邻居多的点可以降低通信成本。&lt;/p&gt;

&lt;h3&gt;Stochastic Learning&lt;/h3&gt;

&lt;p&gt;主讲人：浩锋&lt;/p&gt;

&lt;p&gt;思想：在需要用到所有节点上的信息时，通信代价往往很大，这时可以随机的选取某一个节点上的信息（比如梯度）作为替代品。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://cs.nju.edu.cn/lwj/slides/BigLearning.pdf&quot;&gt;幻灯片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;http://jmlr.csail.mit.edu/proceedings/papers/v32/yan14.pdf&quot;&gt;Coupled Group Lasso for
Web-Scale CTR Prediction in Display Advertising&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【3】&lt;a href=&quot;http://papers.nips.cc/paper/5396-distributed-power-law-graph-computing-theoretical-and-empirical-analysis.pdf&quot;&gt;Distributed Power-law Graph Computing:
Theoretical and Empirical Analysis&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Git常用命令速查表</title>
        <link>http://johnchancfz.github.io/blog/2015/01/30/Git-Resources.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/01/30/Git-Resources.html</guid>
        <pubDate>Fri, 30 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;master: 默认开发分支&lt;/p&gt;

&lt;p&gt;origin: 默认远程版本库&lt;/p&gt;

&lt;p&gt;Head: 默认开发分支&lt;/p&gt;

&lt;p&gt;Head^: Head的父提交&lt;/p&gt;

&lt;h3&gt;创建版本库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git clone &amp;lt;url&amp;gt;   #克隆远程版本库
$ git init          #初始化本地版本库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改和提交&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git status        #查看状态
$ git diff          #查看变更内容
$ git add .         #跟踪所有改动过的文件
$ git add &amp;lt;file&amp;gt;    #跟踪指定的文件
$ git mv &amp;lt;old&amp;gt;&amp;lt;new&amp;gt; #文件改名
$ git rm&amp;lt;file&amp;gt;      #删除文件
$ git rm --cached&amp;lt;file&amp;gt;            #停止跟踪文件但不删除
$ git commit -m &quot;commit messages&quot;  #提交所有更新过的文件
$ git commit --amend               #修改最后一次改动
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看提交历史&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git log                    #查看提交历史
$ git log -p &amp;lt;file&amp;gt;          #查看指定文件的提交历史
$ git blame &amp;lt;file&amp;gt;           #以列表方式查看指定文件的提交历史
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;撤销&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git reset --hard HEAD      #撤销工作目录中所有未提交文件的修改内容
$ git checkout HEAD &amp;lt;file&amp;gt;   #撤销指定的未提交文件的修改内容
$ git revert &amp;lt;commit&amp;gt;        #撤销指定的提交
$ git log --before=&quot;1 days&quot;  #退回到之前1天的版本 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分支与标签&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git branch                   #显示所有本地分支
$ git checkout &amp;lt;branch/tag&amp;gt;    #切换到指定分支和标签
$ git branch &amp;lt;new-branch&amp;gt;      #创建新分支
$ git branch -d &amp;lt;branch&amp;gt;       #删除本地分支
$ git tag                      #列出所有本地标签
$ git tag &amp;lt;tagname&amp;gt;            #基于最新提交创建标签
$ git tag -d &amp;lt;tagname&amp;gt;         #删除标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;合并与衍合&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git merge &amp;lt;branch&amp;gt;        #合并指定分支到当前分支
$ git rebase &amp;lt;branch&amp;gt;       #衍合指定分支到当前分支
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;远程操作&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git remote -v                   #查看远程版本库信息
$ git remote show &amp;lt;remote&amp;gt;        #查看指定远程版本库信息
$ git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;   #添加远程版本库
$ git fetch &amp;lt;remote&amp;gt;              #从远程库获取代码
$ git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #下载代码及快速合并
$ git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #上传代码及快速合并
$ git push &amp;lt;remote&amp;gt; :&amp;lt;branch/tag-name&amp;gt;  #删除远程分支或标签
$ git push --tags                       #上传所有标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;资料链接&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://try.github.io/levels/1/challenges/1&quot;&gt;Try Git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>2015年阅读书单</title>
        <link>http://johnchancfz.github.io/blog/2015/01/29/Book-List-2015.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2015/01/29/Book-List-2015.html</guid>
        <pubDate>Thu, 29 Jan 2015 00:00:00 +0800</pubDate>
        <description></description>
      </item>
    
      <item>
        <title>在Mac上用LaTeX写漂亮的简历</title>
        <link>http://johnchancfz.github.io/blog/2014/12/06/Make-resume-by-LaTeX.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/12/06/Make-resume-by-LaTeX.html</guid>
        <pubDate>Sat, 06 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/resume.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;你会搜索查看到这篇文章，相信就不需要我解释为什么要用LaTeX写Resume了：）&lt;/p&gt;

&lt;p&gt;今晚报名Facebook China Tech Talk，最后一步需要上传简历。看着已经2年没有更新过的简历，好捉急。那时真是年轻，不舍得做减法，恨不能一张A4纸写尽一生。于是索性重新制作一份简历。&lt;/p&gt;

&lt;h3&gt;需要准备&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装好的LaTeX，如果没有安装请参考&lt;a href=&quot;http://painterlin.com/2014/08/10/Using-LaTeX-with-Sublime-and-Skim-for-Mac.html&quot;&gt;在Mac上通过Sublime、Skim编辑LaTeX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互联网&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rpi.edu/dept/arc/training/latex/resumes/&quot;&gt;Using the LaTeX Resume Templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.latextemplates.com/cat/curricula-vitae&quot;&gt;LaTeX Templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在上述资料中寻找自己喜欢的模板&lt;/li&gt;
&lt;li&gt;下载模板对应的tex文件&lt;/li&gt;
&lt;li&gt;用LaTeX打开对应文件，编辑，编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候，如果你使用的是Mac系统，非常不幸，大多数情况下都将编译失败。因为网上多数模板需要使用windows环境下的Tex应用程序，而Mac环境下MacTex应用程序会缺少部分文件。没关系，我们有办法解决。&lt;/p&gt;

&lt;h3&gt;解决方案一：moderncv&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.ctan.org/pkg/moderncv&quot;&gt;http://www.ctan.org/pkg/moderncv &lt;/a&gt;下载&lt;code&gt;moderncv package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解压，找到模板文件&lt;code&gt;template.tex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用已经安装好的LaTeX打开模板文件，编辑，编译，成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是呢，我个人觉得moderncv模板并不够好，虽然其结构清新简洁，但布局过于稀疏。没关系，我们仍然有办法。感谢一个我无意中发现的网站：ShareLaTeX.com&lt;/p&gt;

&lt;h3&gt;解决方案二：ShareLaTeX.com&lt;/h3&gt;

&lt;p&gt;也许你在上面的资料中找到了你最喜欢的模板，却苦于在Mac OS X系统下无法编译成功。这时可以求助于&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，这是一个在线LaTeX编辑网站，并且提供&lt;code&gt;Resume&lt;/code&gt;,&lt;code&gt;Cover Letter&lt;/code&gt;,&lt;code&gt;Journal Article&lt;/code&gt;,&lt;code&gt;Presentation&lt;/code&gt;,&lt;code&gt;Thesis&lt;/code&gt;,&lt;code&gt;Bibliographies&lt;/code&gt;等不同分类的多种模板。最重要的一点事，只需要确定Latex语法无误，再也不需担心什么编译环境、文件缺失等乱七八糟的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，注册账号&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;New Project&lt;/code&gt;，选择&lt;code&gt;CV or Resume&lt;/code&gt;，挑选你喜欢的简历模板&lt;/li&gt;
&lt;li&gt;根据自己的情况编辑，自动或手动编译，保存PDF&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;既然写到这里了，还想讲讲自己对于简历的体会。但我真的是困得不行了。。。。北京第一次不归夜。。。改天再来补全。。。。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>我的报告 Decentralized Privacy-Preserving Low-Rank Matrix Completion</title>
        <link>http://johnchancfz.github.io/blog/2014/11/26/Presentation-at-Chinese-Academy-of-Science.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/11/26/Presentation-at-Chinese-Academy-of-Science.html</guid>
        <pubDate>Wed, 26 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/s1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;我的报告&lt;/h3&gt;

&lt;h4&gt;Section 0: Introduce Myself&lt;/h4&gt;

&lt;p&gt;Page 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Good afternoon everyone! My name is Anya Lin. I&amp;#39;m a second-year master candidate from University of Science and Technology of China. It&amp;#39;s my great pleasure to introduce to you the Decentralized Privacy-Preserving Low-Rank Matrix Completion. It&amp;#39;s a joint work with my supervisor, Prof. Ling from USTC.&lt;/li&gt;
&lt;li&gt;Before I start, I want to express my thanks to Prof. Ling for his patient instructions and help over the last a few months.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Here&amp;#39;s the outline of my presentation.&lt;/li&gt;
&lt;li&gt;First is the introduction.&lt;/li&gt;
&lt;li&gt;And then the centralized matrix completion problem.&lt;/li&gt;
&lt;li&gt;We develop a decentralized algorithm in section 3, and our algorithm is derived from a centralized algorithm as I will talk about in section 2.&lt;/li&gt;
&lt;li&gt;Next, I will introduce the main result of the topology-dependent privacy preservation.&lt;/li&gt;
&lt;li&gt;At last, it&amp;#39;s the conclusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 1: Introduction&lt;/h4&gt;

&lt;p&gt;Page 3&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OK， let&amp;#39;s go into the introduction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 4&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;#39;d like to begin with the concept of matrix completion. So what is matrix completion? As we can see in this picture, we have an incomplete matrix, whose entries are known only for a subset of the whole matrix. And the rank of the matrix is very small compared with the size of the matrix.&lt;/li&gt;
&lt;li&gt;The goal of the matrix completion is to recover all these unknown entries of of the matrix, as the right-side picture shows. Here, Z is the recovery of W.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 5&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There&amp;#39;s many applications of such a problem. Like image processing, recommendation system and so on. Here are 2 examples. The first one is a problem of image processing. The left picture has a lot of noises, or say, only a part of the original picture is known. By using the fact that the original picture is usually low-rank, we can matrix completion to denoise the picture and get a clear version of high quality as the right picture shows.&lt;/li&gt;
&lt;li&gt;The second example is more close to our lives. It&amp;#39;s related to a recommendation system. As you can see, it&amp;#39;s a webpage of Douban Movie. A user sees a movie, such as Interstella, and then scores it on the website. Here we can imagine a huge matrix with rows representing users and columns the movies. This matrix is incomplete and it&amp;#39;s low-rank. Once this matrix is completed, the website can recommend new movies to users.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 6&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now, here comes a privacy concern. First what is privacy? Privacy is the values one considers private. In the example we mentioned just now, the users&amp;#39; scores of the movies are privacy, because one may not want others to know what movies he has seen or likes. Also, the entries of the matrix could be medical records of patients, or selling data of merchants. These data are considered as privacy.&lt;/li&gt;
&lt;li&gt;Obviously, no one wants the leakage of his privacy.&lt;/li&gt;
&lt;li&gt;However, in reality there may exist a malicious agent, a bad guy. For some reasons you have to give your private data to it, but you don&amp;#39;t know wether you can trust it or not.&lt;/li&gt;
&lt;li&gt;In this situation, we need privacy-preservation. Privacy-preservation is the ability to prevent a malicious agent from obtaining or reconstructing the private data.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 2: Centralized Matrix Completion Problem&lt;/h4&gt;

&lt;p&gt;Page 7&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;#39;s go into the centralized matrix completion problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 8&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When we are faced with a low-rank matrix completion problem, the intuitive thought would be to minimize the rank of the matrix, but this is a nonconvex problem. &lt;/li&gt;
&lt;li&gt;Therefore, we insteadly minimize the nuclear-norm the the matrix, since nuclear-norm is the approximation of the rank and it&amp;#39;s convex.&lt;/li&gt;
&lt;li&gt;Another approach is if the rank of matrix is known to be r as a prior theoreticallyor empirically, we can get the matrix factorization formulation. This approach is advantageous over the nuclear-norm approach since the latter one needs sigular value decomposition, which is computationally expensive and even intractable in decentralized computing.&lt;/li&gt;
&lt;li&gt;A centralized algorithm called LMaFit to solve this is as the following steps shows.&lt;/li&gt;
&lt;li&gt;We have to keep in mind that our algorithm is derived from LMaFit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 3: Decentralized Matrix Completion Problem&lt;/h4&gt;

&lt;p&gt;Page 9&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;After the centralized problem, let&amp;#39;s go into the decentralized one.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 10&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In decentralized computing, we have a network composed of L agents.&lt;/li&gt;
&lt;li&gt;There is an undirected edge between two agents if they can communicate with each other through one hop.&lt;/li&gt;
&lt;li&gt;The goal of all the agents in such a network is to collaboratively complete a low-rank matrix in a decentralized fashion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 11&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To be specific, we segment the whole data matrix W into groups of columns. And do the same to Y and Z. Each agent i in the network holds the corresponding Zi, Yi and entries of Wi. &lt;/li&gt;
&lt;li&gt;However, X cannot be segmented and distributed to agents because the update of X contains the summation of ZiYi&amp;#39; over all agents. So we let each agent i holds a local copy X(i) of X.&lt;/li&gt;
&lt;li&gt;After doing this, we get a naive decentralized implementation of LMaFit. At iteration k, each agent i does the following steps respectively.&lt;/li&gt;
&lt;li&gt;Notice that the update of X requires information aggregation of all agents. So here is the challenge: informationaggregationofallagentsisimpossible in real decentralized network unless every agent is connected to all the other agents. &lt;/li&gt;
&lt;li&gt;How to deal with this challenge?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 12&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The answer is dynamic average consensus. Recall that each agent i holds a local copy X(i) of X. If we can make sure that X(i) equals to X for all i, the challenge is solved. &lt;/li&gt;
&lt;li&gt;To do this, we choose c to be 1/L and the update of X becomes the average consensus problem, as we can see in equation (8), X(i) is the average of all the ZiYi&amp;#39;.&lt;/li&gt;
&lt;li&gt;At iteration k,we formulate the average consensus problem as equation (9). The constraint means that instead of letting all the X(i) to be identical we choose to let each X(i) equals to it neighboring X(j).&lt;/li&gt;
&lt;li&gt;A key observation is that exact average consensus at every iteration is not necessary. We use EXTRA to do inexact dynamic average consensus, which saves the computational cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 13&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Our decentralized algorithm called D-LMaFit is developed as below.&lt;/li&gt;
&lt;li&gt;Step 1 is the initialization.&lt;/li&gt;
&lt;li&gt;Step 2, use EXTRA to do the inexact average consensus problem.&lt;/li&gt;
&lt;li&gt;Step 3, update Y and X respectively. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 14&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The performance of D-LMaFit is shown in these two pictures. (Explain what these pictures indicate to the audience)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 4: Topology-Dependent Privacy Preservation&lt;/h4&gt;

&lt;p&gt;Page 15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;#39;s go into the section of the topology-dependent privacy preservation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 16&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First compare decentralized algorithm with centralized one.&lt;/li&gt;
&lt;li&gt;Centralized algorithm needs a fusion center to collect global data. What if the fusion center is a malicious agent?&lt;/li&gt;
&lt;li&gt;Oops TT, you&amp;#39;ll lose all your privacy.&lt;/li&gt;
&lt;li&gt;How about the decentralzied algorithm? One important advantage of decentralized algortihm over a centralized is there&amp;#39;s no global data collection, each agent observes part of the raw data and communicates with its neighboring agent(s). It seems safer.&lt;/li&gt;
&lt;li&gt;But things aren&amp;#39;t so lucky in reality. Because the communication of X(i) among the network may lead to information leakage.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 17&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How does this happen? Suppose in a network as this picture shows, we have a malicious agent M, and M attempts to recover the local data matrices of some other agents through information exchange.&lt;/li&gt;
&lt;li&gt;M is interested in recovering the local data Wi, or equivalently Yi or Zi of a set of agents i∈I.&lt;/li&gt;
&lt;li&gt;When the iteration k is large enough, X(i) will be identical. So if a malicious agent M somehow knows other agents&amp;#39; Yi, it can recover the data Zi of agent i by doing X(M)Yi.&lt;/li&gt;
&lt;li&gt;So our concern is, is there any possibility that the malicious agent M can somehow obtain Yi of agent i, and thus get Zi, which is private.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 18&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Before going to details, consider two simple topologies.&lt;/li&gt;
&lt;li&gt;(Explain the two topologies)&lt;/li&gt;
&lt;li&gt;Under what conditions can not a malicious agent M reconstruct the sensitive information of P and Q ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 19&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Recall the update of X.&lt;/li&gt;
&lt;li&gt;If you could just take a look at the equation, you can find that if the topology is as in the left picture, M can reconstruct ZiYi&amp;#39; and it may be able to solve Yi so that gets the privacy of P and Q.&lt;/li&gt;
&lt;li&gt;But if the topology is as shown in the right picture. M cannot get the private data of P and Q. Why?&lt;/li&gt;
&lt;li&gt;(Explain with the equation)&lt;/li&gt;
&lt;li&gt;M can solve a series of linear inverse problems and calculate the values of ZiYi&amp;#39;, as what we have said just now.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 20&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now we get a naive conclusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 21&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;So the privacy-preserving problem boils down to the linear inverse problem. First we define some variables as this.&lt;/li&gt;
&lt;li&gt;And further we define A and B.&lt;/li&gt;
&lt;li&gt;Using these definition,the update of X can be represented by (14).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 22&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rewrite this as a linear time-invariant systems we get (15). In this system, QI selects those row blocks in Q belonging to the agents in I, and BI selects the corresponding columns in B. QIC and BIC selects the other corresponding row blocks and columns which do not belong to the agents in I.&lt;/li&gt;
&lt;li&gt;Our analysis uses the concept of z-transfer matrix of (15). The concept is from modern control theory.&lt;/li&gt;
&lt;li&gt;Obviously, rank(T)=rank(TI TIC), since the latter matrix is just a column rearrangement of the former one. &lt;/li&gt;
&lt;li&gt;Now we are ready to develop our theorem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 23&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check the proof of the suffienciency of our theorem, it&amp;#39;s rather straightforward.&lt;/li&gt;
&lt;li&gt;If this condition is satisfired, then M has full knowledge of all the X(i).&lt;/li&gt;
&lt;li&gt;So M can solve a series of linear inverse problems.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 24&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The proof of necessity is a little bit complicated. Here&amp;#39;s the only the simplified version of the proof.&lt;/li&gt;
&lt;li&gt; First we show that to determine a unique sequence of Q􏰇 from V􏰇 , we must have (18).&lt;/li&gt;
&lt;li&gt;Suppose (18) doesn&amp;#39;t hold, then there exists at least one column of TI that is linearly dependent on the other columns of T. Then there exists a Q with that column nonzero, and satisfies TQ=0. This corresponds to a nonzero input in I, but the output V is zero for all time. Thus this nonzero input cannot be recovered. This contradicts with the hypothesis. So (18) must hold.&lt;/li&gt;
&lt;li&gt;(Explain these items)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 25&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(Explain these items)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 5: Conclusion&lt;/h4&gt;

&lt;p&gt;Page 26&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;#39;d like to quickly go over the main point of today&amp;#39;s topic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 27&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First, we propose a decentralized privacy-preserving algorithm, D-LMaFit, to solve the matrix completion problem.&lt;/li&gt;
&lt;li&gt;We solve dynamic average consensus subproblem inexactly.&lt;/li&gt;
&lt;li&gt;We prove the topology-dependent privacy-preserving theorem. It provides a guideline of designing a privacy-preserving network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 28&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Still we&amp;#39;ve got work to do in the future. (Read items)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 29&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I guess that&amp;#39;s it. Thank you all very much for listening. Now if you have any question, please feel free to ask me.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;故事&lt;/h3&gt;

&lt;p&gt;这学期我在中科院数学与系统科学研究院(AMSS)访问。第一次参与这边的讨论班时，我就被惊到了：学生做报告也全程英文，不愧是&lt;a href=&quot;http://lsec.cc.ac.cn/%7Eyyx/chinese/indexc.htm&quot;&gt;袁亚湘&lt;/a&gt;老师的学生。于是，11月25日，我也在这儿完成了自己第一次的英文学术报告。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;报告前3天，我问盛镇醴师兄他们报告前会不会排练，师兄说：“肯定要啊！上次去葡萄牙开会，&lt;a href=&quot;http://www.se.cuhk.edu.hk/people/sqma.html&quot;&gt;马士谦&lt;/a&gt;师兄已经讲得那么好了，都还又自己私下练习了5、6遍。师兄真的可以做到每句话精确到几秒钟！”太荔枝了有木有TT。&lt;/li&gt;
&lt;li&gt;于是我也练习了。果然只有努力了内心才会踏实。在当天的报告中，我不仅不紧张，还在瞅到台下一堆人的专注神情时，心里突然弹幕全开：“哇，这感觉好爽。”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在记录报告之前，插播一段回忆：
大三暑假，我参加&lt;a href=&quot;http://china.ican-contest.org/index.html&quot;&gt;中国大学生物联网创新创业大赛&lt;/a&gt;，正式比赛前一天系里组织答辩练习，我们组讲得一塌糊涂。那一晚，我和向国菲师兄在实验室通宵改幻灯片，准备发言稿，然后一句一句地练习。中途师兄压力太大又累得不行溜出去躲着抽了根烟，回来被我发现了教育了一顿，嗅觉就是这么灵敏没办法。直到凌晨4点，终于觉得还算满意了，两人躺椅子上睡了会儿，当然我被蚊子咬安逸了。早晨7点，寝室开门，两人各自回去洗澡调整状态。9点，开始比赛。不知道为什么突然想起这个，太，美好了。尽管当时觉得真苦逼。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.zhihu.com/question/24544386/answer/30237316&quot;&gt;有哪些高级的英语表达技巧，让人一听就很地道？&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>凸优化的一些基础算法</title>
        <link>http://johnchancfz.github.io/blog/2014/11/10/Basic-Algorithms-of-Convex-Opt.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/11/10/Basic-Algorithms-of-Convex-Opt.html</guid>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;本文假设读者对凸优化有基本了解，主要归纳一些基础算法，以便查阅。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\min&amp;space;f(x)&amp;space;\triangleq&amp;space;g(x)&amp;plus;h(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\min&amp;space;f(x)&amp;space;\triangleq&amp;space;g(x)&amp;plus;h(x)&quot; title=&quot;\min f(x) \triangleq g(x)+h(x)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中，f，g，h都是凸函数，g是光滑项，h是非光滑项。&lt;/p&gt;

&lt;h3&gt;Gradient Descent&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&amp;plus;=x-\alpha\nabla&amp;space;f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&amp;plus;=x-\alpha\nabla&amp;space;f(x)&quot; title=&quot;x^+=x-\alpha\nabla f(x)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Proximal Gradient&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&amp;plus;=prox_{\alpha&amp;space;h}(x-\alpha&amp;space;\nabla&amp;space;g(x))=&amp;space;\arg\min_u&amp;space;h(u)&amp;plus;\frac{1}{2\alpha}||u-x&amp;plus;\alpha&amp;space;\nabla&amp;space;g(x)||&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&amp;plus;=prox_{\alpha&amp;space;h}(x-\alpha&amp;space;\nabla&amp;space;g(x))=&amp;space;\arg\min_u&amp;space;h(u)&amp;plus;\frac{1}{2\alpha}||u-x&amp;plus;\alpha&amp;space;\nabla&amp;space;g(x)||&quot; title=&quot;x^+=prox_{\alpha h}(x-\alpha \nabla g(x))= \arg\min_u h(u)+\frac{1}{2\alpha}||u-x+\alpha \nabla g(x)||&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Conjugate Gradient&lt;/h3&gt;

&lt;p&gt;是介于最速下降法和牛顿法之间的一个方法，它仅需要利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hession并求逆的缺点。它是解决大型线性方程组最有用的方法之一，也是解决大型非线性最优化最有效的算法之一。&lt;/p&gt;

&lt;h3&gt;Newton&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html&quot;&gt;牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Quasi Newton&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html&quot;&gt;牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>什么是 P, NP, NP-complete, NP-hard</title>
        <link>http://johnchancfz.github.io/blog/2014/11/09/What-is-NP-Hard.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/11/09/What-is-NP-Hard.html</guid>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;相关概念&lt;/h3&gt;

&lt;p&gt;NP-hard（non-deterministic polynomial-time hard）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;P：能在多项式时间内解决&lt;/li&gt;
&lt;li&gt;NP：不能在多项式时间内解决或不确定能不能在多项式时间内解决，但一旦你找到一个解，只需要多项式时间去验证这个解是正确的&lt;/li&gt;
&lt;li&gt;NP-hard：如果一个问题是NP-hard，意味着可以将任意NP问题化约到这个问题。如果可以解这个问题，那么可以轻松地解任意NP问题。&lt;/li&gt;
&lt;li&gt;NPC：NP完全问题，所有NP问题在多项式时间内都能化约（Reducibility）到某一NP问题，这一NP问题就是NPC问题，即解决了此NPC问题，所有NP问题也都解决了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;资料原文&lt;/h3&gt;

&lt;p&gt;These refer to how long it takes a program to run.  Problems in class P can be solved with algorithms that run in &lt;strong&gt;polynomial time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Say you have an algorithm that finds the smallest integer in an array.  One way to do this is by iterating over all the integers of the array and keeping track of the smallest number you&amp;#39;ve seen up to that point.  Every time you look at an element, you compare it to the current minimum, and if it&amp;#39;s smaller, you update the minimum.&lt;/p&gt;

&lt;p&gt;How long does this take?  Let&amp;#39;s say there are n elements in the array.  For every element the algorithm has to perform a constant number of operations.  Therefore we can say that the algorithm runs in O(n) time, or that the runtime is a linear function of how many elements are in the array.  So this algorithm runs in &lt;strong&gt;linear time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You can also have algorithms that run in &lt;strong&gt;quadratic time&lt;/strong&gt; (O(n^2)), &lt;strong&gt;exponential time&lt;/strong&gt; (O(2^n)), or even &lt;strong&gt;logarithmic time&lt;/strong&gt; (O(log n)).  Binary search (on a balanced tree) runs in logarithmic time because the height of the binary search tree is a logarithmic function of the number of elements in the tree.&lt;/p&gt;

&lt;p&gt;If the running time is some polynomial function of the size of the input, for instance if the algorithm runs in linear time or quadratic time or cubic time, then we say the algorithm runs in &lt;strong&gt;polynomial time&lt;/strong&gt; and the problem it solves is in class &lt;strong&gt;P&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Now there are a lot of programs that don&amp;#39;t (necessarily) run in polynomial time on a regular computer, but do run in polynomial time on a nondeterministic Turing machine.  These programs solve problems in &lt;strong&gt;NP&lt;/strong&gt;, which stands for &lt;strong&gt;nondeterministic polynomial time&lt;/strong&gt;.  A nondeterministic Turing machine can do everything a regular computer can and more. This means all problems in P are also in NP.&lt;/p&gt;

&lt;p&gt;An equivalent way to define NP is by pointing to the problems that can be verified in polynomial time.  This means there is not necessarily a polynomial-time way to find a solution, but once you have a solution it only takes polynomial time to verify that it is correct.&lt;/p&gt;

&lt;p&gt;Some people think P = NP, which means any problem that can be verified in polynomial time can also be solved in polynomial time and vice versa.  If they could prove this, it would revolutionize computer science because people would be able to construct faster algorithms for a lot of important problems.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP-hard&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;What does NP-hard mean?  A lot of times you can solve a problem by reducing it to a different problem.  I can reduce Problem B to Problem A if, given a solution to Problem A, I can easily construct a solution to Problem B.  (In this case, &amp;quot;easily&amp;quot; means &amp;quot;in polynomial time.&amp;quot;)&lt;/p&gt;

&lt;p&gt;If a problem is &lt;strong&gt;NP-hard&lt;/strong&gt;, this means I can reduce any problem in NP to that problem.  This means if I can solve that problem, I can easily solve any problem in NP.  If we could solve an NP-hard problem in polynomial time, this would prove P = NP.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;A problem is &lt;strong&gt;NP-complete&lt;/strong&gt; if the problem is both&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NP-hard, and&lt;/li&gt;
&lt;li&gt;in NP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.quora.com/What-are-P-NP-NP-complete-and-NP-hard&quot;&gt;What are P, NP, NP-complete, and NP-hard?&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>海岸公路</title>
        <link>http://johnchancfz.github.io/blog/2014/11/03/Coast.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/11/03/Coast.html</guid>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/days/coast.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;故事&lt;/h3&gt;

&lt;p&gt;我生日的时候，这货送我一套绘画工具作为礼物，条件是她生日的时候我要画幅画给她。&lt;/p&gt;

&lt;p&gt;所以，生日快乐啊邓怡。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Yosemite OS X 10.10 Matlab 2012a停止工作的解决办法</title>
        <link>http://johnchancfz.github.io/blog/2014/10/31/Yosemite-Matlab-Running-Error.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/10/31/Yosemite-Matlab-Running-Error.html</guid>
        <pubDate>Fri, 31 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;OS X 系统更新到Yosemite后，Matlab 2012a就无法运行了。&lt;/p&gt;

&lt;h3&gt;解决步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://xquartz.macosforge.org/landing/&quot;&gt;XQuartz&lt;/a&gt;下载&lt;code&gt;XQuartz-2.7.7.dmg&lt;/code&gt;，并安装更新。&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行命令：&lt;code&gt;
sudo ln -s /opt/X11/ /usr/X11
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载并安装&lt;a href=&quot;http://support.apple.com/kb/DL1572&quot;&gt;Java 6&lt;/a&gt;更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;完成✌️&lt;/h3&gt;

&lt;p&gt;OK，现在Matlab就能重新工作了。&lt;/p&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://brainsuite.org/quickstart/installation/mac/yosemite/&quot;&gt; running svreg and bdp on yosemite (os x 10.10)&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac安装unrar和rar解压缩工具</title>
        <link>http://johnchancfz.github.io/blog/2014/10/07/Mac-Rar-Unrar.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/10/07/Mac-Rar-Unrar.html</guid>
        <pubDate>Tue, 07 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;Mac不能解压rar文件，但实际中会需要这项功能。比如从邮件中的附件时常以rar文件格式传输。&lt;/p&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.rarlab.com/download.htm&quot;&gt;rarlab&lt;/a&gt;下载&lt;code&gt;RAR 5.20 beta 1 for Mac OS X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行解压缩命令：tar xvfz rarosx-5.2.b1.tar进行解压&lt;/li&gt;
&lt;li&gt;进入刚刚解压的rar目录中，cd downloads/rar&lt;/li&gt;
&lt;li&gt;在rar目录下使用如下命令进行安装&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sudo install -c -o$USER unrar /bin
sudo install -c -o$USER rar /bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;解压与压缩&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;unrar x filename.rar             #解压
rar a archivename.rar filename   #压缩
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;为什么要折腾这个，因为今天收到一份rar格式的文件。
转眼一年了，好快啊。这是要每年送我一个生日蛋糕的节奏吗？如果是的话，这篇博客需要每年更新一次。&lt;/p&gt;

&lt;h4&gt;2013年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2014年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2015年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/3.jpg&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;h3&gt;谢意&lt;/h3&gt;

&lt;p&gt;蒲俊楠童鞋，阿里嘎多~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>阿里巴巴大数据竞赛回顾与总结</title>
        <link>http://johnchancfz.github.io/blog/2014/10/01/Alibaba-Big-Data.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/10/01/Alibaba-Big-Data.html</guid>
        <pubDate>Wed, 01 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;8个月前，苏宇师兄问我对&lt;a href=&quot;http://102.alibaba.com/competition/addDiscovery/index.htm&quot;&gt;阿里巴巴大数据竞赛&lt;/a&gt;感兴趣吗。正好我选修了&lt;a href=&quot;http://staff.ustc.edu.cn/%7Echeneh/&quot;&gt;陈恩红&lt;/a&gt;老师的《机器学习与数据挖掘》，很好奇这门课在实际中的应用；身为淘宝用户，也好奇我是如何被推荐的。于是和师兄一起参加比赛，加上计算机学院的刘惠民同学，我们组成了名叫&lt;code&gt;Rosemary&lt;/code&gt;三人团队。这次大赛总共有7276支队伍参赛，我们止步于第二赛季。第一赛季排名56；第二赛季排名68。&lt;/p&gt;

&lt;h3&gt;开放数据&lt;/h3&gt;

&lt;table  class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
   &lt;tr&gt;
     &lt;th&gt;字段&lt;/th&gt;
      &lt;th&gt;字段说明&lt;/th&gt;
      &lt;th&gt;提取说明&lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;user_id&lt;/td&gt;
      &lt;td&gt;用户标记&lt;/td&gt;
      &lt;td&gt;抽样、字段加密&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;Time&lt;/td&gt;
      &lt;td&gt;行为时间&lt;/td&gt;
      &lt;td&gt;精度到天级别、隐藏年份&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;action_type&lt;/td&gt;
      &lt;td&gt;用户对品牌的行为类型&lt;/td&gt;
      &lt;td&gt;包括点击（0）、购买（1）、加入购物车（2）、收藏（3）四种行为 &lt;/td&gt;
  &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;brand_id&lt;/td&gt;
      &lt;td&gt;品牌数字ID&lt;/td&gt;
      &lt;td&gt;抽样、字段加密&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;比赛任务&lt;/h3&gt;

&lt;p&gt;根据用户4个月在天猫的行为日志，建立用户的品牌偏好，并预测他们在将来一个月内对品牌下商品的购买行为。&lt;/p&gt;

&lt;h3&gt;评估指标&lt;/h3&gt;

&lt;p&gt;大赛最终的比赛成绩排名以F1得分为准。&lt;/p&gt;

&lt;p&gt;准确率：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Precision=\frac{\sum_i^N&amp;space;hitBrands_i}{\sum_i^N&amp;space;pBrands_i}&quot; title=&quot;Precision=\frac{\sum_i^N hitBrands_i}{\sum_i^N pBrands_i}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;召回率：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Recall=\frac{\sum_i^M&amp;space;hitBrands_i}{\sum_i^M&amp;space;bBrands_i}&quot; title=&quot;Recall=\frac{\sum_i^M hitBrands_i}{\sum_i^M bBrands_i}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;F1-Score：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?F_1=\frac{2\times&amp;space;P\times&amp;space;R}{P&amp;plus;R}&quot; title=&quot;F_1=\frac{2\times P\times R}{P+R}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N 为参赛队预测的用户数；M 为实际产生成交的用户数量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;pBrandsi为对用户i 预测他(她)会购买的品牌列表个数；bBrandsi为用户i 真实购买的品牌个数 &lt;/li&gt;
&lt;li&gt;hitBrandsi对用户i预测的品牌列表与用户i真实购买的品牌交集的个数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;解读&lt;code&gt;准确率&lt;/code&gt;、&lt;code&gt;召回率&lt;/code&gt;和&lt;code&gt;F1-Score&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;准确率就是正确预测数目比上预测总数目。召回率就是正确预测数目比上真实总数目。F1-Score是准确率和召回率的调和平均。理论上，准确率与召回率并没有必然的联系；但在实际中，这二者往往此消彼长、相互制约。有研究表明，在不牺牲准确率的情况下，获得一个高召回率是很难的。在赛题环境下举个栗子：&lt;/p&gt;

&lt;table  class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
   &lt;tr&gt;
     &lt;th&gt;我们预测出&lt;/th&gt;
      &lt;th&gt;会有3个人买东西，A买品牌a，B买品牌b，C买P品牌c&lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;真实情况是&lt;/td&gt;
      &lt;td&gt;有4个人买了东西，这4个人分别是A，B，C，D，其中A买a和b，B买b，C买b和c，D买a。&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;按照我们的预测，准确率达到了100%，而召回率仅为50%。由此可见，想取得一个较好的F1-Score成绩，需要保证预测的数据尽量hit之外，还要保证预测的数据能够覆盖尽量多的真实数据。具体到比赛中，就需要很好地确定每个被预测的用户可能会买多少个品牌。&lt;/p&gt;

&lt;p&gt;通过对这三个评判标准的分析，我们初步确定了第一赛季所用的策略。&lt;/p&gt;

&lt;h3&gt;第一赛季&lt;/h3&gt;

&lt;p&gt;大致的方案是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加权对用户4种行为次数求和，得到简单的用户ID（行）与品牌ID（列）的&lt;code&gt;兴趣度&lt;/code&gt;（值）矩阵。&lt;/li&gt;
&lt;li&gt;统计前4个月平均每个月有多少用户购买超过2个品牌的东西，记为B。&lt;/li&gt;
&lt;li&gt;根据用户前4个月的购买行为，按照&lt;code&gt;购买力&lt;/code&gt;划分用户购买等级。直白解释就是你以前在天猫上平均每个月买了多少次，我就假设你下个月还会买这么多次。&lt;/li&gt;
&lt;li&gt;第一次切分兴趣度矩阵，保留前B行矩阵。&lt;/li&gt;
&lt;li&gt;对每个用户对不同品牌的兴趣度由高到低排序，再根据每个用户的购买力确定对该用户保留前n列的兴趣数据，并预测他会买这n个数据对应的品牌。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，在最初的模型建立起来之后，我们还陆续加了一些规则，比如在&lt;code&gt;时间节截止点&lt;/code&gt;(最后N天，N可以根据自己的理解取值)的单独分析。另外，调参数真就是一项体力活。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/s1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第二赛季&lt;/h3&gt;

&lt;p&gt;（好困，需要去睡觉Zzz···）细节未完待续&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/score0.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;
</description>
      </item>
    
      <item>
        <title>Linux 4：磁盘与文件系统管理</title>
        <link>http://johnchancfz.github.io/blog/2014/09/30/Linux4.html</link>
        <guid isPermaLink="true">http://johnchancfz.github.io/blog/2014/09/30/Linux4.html</guid>
        <pubDate>Tue, 30 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;认识EXT2文件系统&lt;/h3&gt;

&lt;p&gt;每种操作系统能够使用的文件系统并不相同。 举例来说，windows 98以前的微软操作系统主要利用的文件系统是&lt;code&gt;FAT(或FAT16)&lt;/code&gt;，windows 2000以后的版本有所谓的&lt;code&gt;NTFS&lt;/code&gt;文件系统，至于Linux的正统文件系统则为&lt;code&gt;Ext2&lt;/code&gt;(Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows操作系统是不会认识Linux的Ext2的。&lt;/p&gt;

&lt;p&gt;那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到&lt;code&gt;inode&lt;/code&gt;中，至于实际数据则放置到&lt;code&gt;data block&lt;/code&gt;区块中。 另外，还有一个超级区块(&lt;code&gt;superblock&lt;/code&gt;)会记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等。&lt;/p&gt;

&lt;h3&gt;文件系统的简单操作&lt;/h3&gt;

&lt;h3&gt;磁盘的分割、格式化、检验与挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;磁盘分区： fdisk, partprobe&lt;/li&gt;
&lt;li&gt;磁盘格式化： mkfs, mke2fs&lt;/li&gt;
&lt;li&gt;磁盘检验： fsck, badblocks&lt;/li&gt;
&lt;li&gt;磁盘挂载与卸除： mount, umount&lt;/li&gt;
&lt;li&gt;磁盘参数修订： mknod, e2label, tune2fs, hdparm&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置启动挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;启动挂载 /etc/fstab 及 /etc/mtab&lt;/li&gt;
&lt;li&gt;特殊装置 loop 挂载(映象档不刻录就挂载使用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;内存置换空间(swap)之建置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用实体分割槽建置swap&lt;/li&gt;
&lt;li&gt;使用文件建置swap&lt;/li&gt;
&lt;li&gt;swap使用上的限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;文件系统的特殊观察与操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;boot sector 与 superblock 的关系&lt;/li&gt;
&lt;li&gt;磁盘空间之浪费问题&lt;/li&gt;
&lt;li&gt;利用 GNU 的 parted 进行分割行为&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;重点回顾&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本上 Linux 的正统文件系统为 Ext2 ，该文件系统内的信息主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；&lt;/li&gt;
&lt;li&gt;inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；&lt;/li&gt;
&lt;li&gt;block：实际记录文件的内容，若文件太大时，会占用多个 block 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2 文件系统的数据存取为索引式文件系统(indexed allocation)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;inode 记录文件的属性/权限等数据，其他重要项目为： 每个 inode 大小均固定为 128 bytes； 每个文件都仅会占用一个 inode 而已； 因此文件系统能够创建的文件数量与 inode 的数量有关；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录底下文件名与其 inode 号码的对照表；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志式文件系统 (journal) 会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux 文件系统为添加效能，会让主存储器作为大量的磁盘高速缓存；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实体链接只是多了一个文件名对该 inode 号码的链接而已；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;符号链接就类似Windows的快捷方式功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘的使用必需要经过：分割、格式化与挂载，分别惯用的命令为：fdisk, mkfs, mount三个命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动自动挂载可参考/etc/fstab之配置，配置完毕务必使用 mount -a 测试语法正确否；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem.php#harddisk&quot;&gt;鸟哥的Linux私房菜 第八章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
  </channel>
</rss>